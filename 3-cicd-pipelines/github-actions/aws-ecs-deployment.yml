name: 'Deploy to AWS ECS Fargate'

on:
  push:
    branches: [main, develop]
    paths-ignore:
      - 'docs/**'
      - '*.md'
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: document-processor
  ECS_SERVICE: document-processor-service
  ECS_CLUSTER: production-cluster
  CONTAINER_NAME: document-processor

# Use OIDC for secure AWS authentication
permissions:
  id-token: write
  contents: read
  security-events: write
  pull-requests: write

jobs:
  # Determine deployment environment and settings
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      deploy: ${{ steps.env.outputs.deploy }}
      ecr_registry: ${{ steps.env.outputs.ecr_registry }}
      image_tag: ${{ steps.env.outputs.image_tag }}
    steps:
      - name: Determine Environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "deploy=false" >> $GITHUB_OUTPUT
          fi
          
          echo "ecr_registry=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT

  # Build and test the application
  build:
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-ECS-Build
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ needs.setup.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ needs.setup.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.setup.outputs.image_tag }}
            ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            ENVIRONMENT=${{ needs.setup.outputs.environment }}

      - name: Run security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.setup.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.setup.outputs.image_tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload security scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Deploy to ECS
  deploy:
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: needs.setup.outputs.deploy == 'true'
    environment: 
      name: ${{ needs.setup.outputs.environment }}
      url: ${{ steps.deploy.outputs.service-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-ECS-Deploy
          aws-region: ${{ env.AWS_REGION }}

      - name: Download task definition
        run: |
          aws ecs describe-task-definition \
            --task-definition ${{ env.ECS_SERVICE }} \
            --query taskDefinition > task-definition.json

      - name: Update container image in task definition
        id: update-image
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ needs.setup.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.setup.outputs.image_tag }}

      - name: Configure secrets and monitoring
        id: configure-task-def
        uses: ./3-cicd-pipelines/custom-actions/aws-taskdef-action
        with:
          task-definition: ${{ steps.update-image.outputs.task-definition }}
          container-name: ${{ env.CONTAINER_NAME }}
          config-path: deployment-configs/service-configs/document-processor.yml
          environment: ${{ needs.setup.outputs.environment }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to Amazon ECS
        id: deploy
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.configure-task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true

      - name: Get service URL
        id: service-url
        run: |
          SERVICE_ARN=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].serviceArn' \
            --output text)
          
          LOAD_BALANCER_ARN=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].loadBalancers[0].targetGroupArn' \
            --output text)
          
          if [[ "$LOAD_BALANCER_ARN" != "None" ]]; then
            LB_ARN=$(aws elbv2 describe-target-groups \
              --target-group-arns $LOAD_BALANCER_ARN \
              --query 'TargetGroups[0].LoadBalancerArns[0]' \
              --output text)
            
            SERVICE_URL=$(aws elbv2 describe-load-balancers \
              --load-balancer-arns $LB_ARN \
              --query 'LoadBalancers[0].DNSName' \
              --output text)
            
            echo "service-url=https://$SERVICE_URL" >> $GITHUB_OUTPUT
          else
            echo "service-url=No load balancer configured" >> $GITHUB_OUTPUT
          fi

      - name: Verify deployment
        run: |
          echo "Deployment completed successfully!"
          echo "Service: ${{ env.ECS_SERVICE }}"
          echo "Cluster: ${{ env.ECS_CLUSTER }}"
          echo "Image: ${{ needs.setup.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.setup.outputs.image_tag }}"
          echo "Environment: ${{ needs.setup.outputs.environment }}"
          
          # Wait for service to be stable
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}
          
          # Get running task count
          RUNNING_TASKS=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].runningCount' \
            --output text)
          
          echo "Running tasks: $RUNNING_TASKS"

      - name: Post deployment notification
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          fields: repo,message,commit,author,action,eventName,ref,workflow
          custom_payload: |
            {
              "text": "ECS Deployment ${{ job.status }}",
              "attachments": [{
                "color": "${{ job.status }}" === "success" ? "good" : "danger",
                "fields": [{
                  "title": "Environment",
                  "value": "${{ needs.setup.outputs.environment }}",
                  "short": true
                }, {
                  "title": "Service",
                  "value": "${{ env.ECS_SERVICE }}",
                  "short": true
                }, {
                  "title": "Image Tag",
                  "value": "${{ needs.setup.outputs.image_tag }}",
                  "short": true
                }, {
                  "title": "Service URL",
                  "value": "${{ steps.service-url.outputs.service-url }}",
                  "short": false
                }]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Rollback job (manual trigger)
  rollback:
    runs-on: ubuntu-latest
    if: failure() && needs.setup.outputs.environment == 'prod'
    needs: [setup, deploy]
    environment: 
      name: ${{ needs.setup.outputs.environment }}-rollback
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          role-session-name: GitHubActions-ECS-Rollback
          aws-region: ${{ env.AWS_REGION }}

      - name: Get previous task definition
        id: previous-task-def
        run: |
          # Get the previous task definition revision
          CURRENT_REVISION=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text | sed 's/.*://')
          
          PREVIOUS_REVISION=$((CURRENT_REVISION - 1))
          
          if [[ $PREVIOUS_REVISION -gt 0 ]]; then
            TASK_DEF_FAMILY=$(aws ecs describe-services \
              --cluster ${{ env.ECS_CLUSTER }} \
              --services ${{ env.ECS_SERVICE }} \
              --query 'services[0].taskDefinition' \
              --output text | sed 's/:.*//')
            
            echo "previous-task-definition=${TASK_DEF_FAMILY}:${PREVIOUS_REVISION}" >> $GITHUB_OUTPUT
          else
            echo "No previous revision found for rollback"
            exit 1
          fi

      - name: Rollback deployment
        if: steps.previous-task-def.outputs.previous-task-definition
        run: |
          echo "Rolling back to: ${{ steps.previous-task-def.outputs.previous-task-definition }}"
          
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.previous-task-def.outputs.previous-task-definition }}
          
          # Wait for rollback to complete
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}
          
          echo "Rollback completed successfully" 